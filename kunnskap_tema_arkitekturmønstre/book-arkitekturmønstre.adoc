////
Guide to the below header attributes:

    lang: en; no
    difi_orig_language: en; no
    difi_translation_status: -; missing; incomplete; OK 
    keywords_en: comma separated list of english keywords (no controlled vocabulary); TBD
    keywords_no: comma separated list of Norwegian keywords (no controlled vocabulary); TBD  
    
Note: The _lang_ value may be overridden by a command line parameter.
////

:lang: en
:difi_orig_language: en
:doctitle_en: Architecture Patterns
:doctitle_no: Arkitekturmønstre
:difi_translation_status: -
:keywords_en: TBD
:keywords_no: TBD
:toclevels: 3
:difi_doctype: Basic Book Template

// The above parameters are processed by scripts included by the following statement
include::../plattform_felles/includes/commonincludes.adoc[]


// [.lead]
// Architecture Patterns...

////
////

image:../plattform_felles/media/i-arbeid.png[width=45, height=45] _In work (early stage, 2019)._

== Introduction
//.Figure: Value Stream Modeling Relationships
//image:../kunnskap_tema_value_streams\media\value-stream-metamodel.png[value-stream-metamodel]

This is a collection of architecture patterns, and references to information about architecture patterns, to serve as common reference for work with reference architectures and patterns among peers

There are numerous such sources, ranging from ad hoc blogs to extensive books. There are also different types of patterns,such as e.g. software architecture patterns, data exchange patterns or messaging patterns.

It is out of scope here to write a new text book og provide a complete and consistent framework. 

The focus is on the most common and the most relevant patterns with regard to data exchange and integration.



== Integration Styles
=== Remote Procedure Invocation
Source: https://dzone.com/articles/introduction-to-integration-patterns


Remote procedure invocation (RPI) is a pioneer in the integration space and was the go-to manner to implement an API in the early days of computing.In this approach, a provider will allow an external process to make requests into a closed application. The external caller has the specifications to make the request and an expectation on what the response will be, but all the logic takes place using a black-box approach. In this case, RPI is the mechanism used to perform some action against the target system.

Consider an application which handles financial transactions. Prior to the popularity of RESTful APIs, the vendor may offer an API to allow transactions to be posted from an external source. This API was implemented using RPI.

The developer would write a program to gather the required information, then connect to the application using RPI. The results of the RPI/API requests were packaged in a response and that information was processed by the calling application.

=== Shared Database
Source: https://dzone.com/articles/introduction-to-integration-patterns

The shared database integration style leverages a database for the connectivity between two or more applications. As a result, each application would maintain a connection to a shared database containing the information that will be integrated.

As an example, use of an INSERT statement to a staging table in the database could trigger a stored procedure which would perform business logic — ultimately updating attributes elsewhere in the database for other applications utilizing that same shared database integration.

=== Messaging

Source: https://dzone.com/articles/introduction-to-integration-patterns

The messaging integration style started to gain momentum with service-oriented architecture (SOA) implementations — leveraging an enterprise service bus (ESB) as the foundation for the message itself.

Using the financial transaction example, the custom application may simply place a message on the ESB requesting a certain transaction be posted. That system submits the message and relies on the messaging integration style to handle any remaining tasks.

On the financial system side, the message being placed on the bus triggers and event which consumes the message and takes the appropriate action based upon the nature of the message. Based on the message queue used and/or metadata within the message itself, the financial system understands the task that needs to be performed.

When completed, the financial system may place a new message on the bus, which could be consumed by the original system. In this case, it might be related to unique transaction information to append to the original request for auditor validation purposes.



== Patterns for Event-Driven Architecture (EDA)
:leveloffset: +1

include::EDA patterns.adoc[]

:leveloffset!:


== Top 5 Data integration patterns, ref. Mulesoft

=== Migration (Mulesoft)
include::Mulesoft top 5.1 Migration.adoc[]
=== Broadcast (Mulesoft)
include::Mulesoft top 5.2 Broadcast.adoc[]
=== Bi-Directional Sync (Mulesoft)
include::Mulesoft top 5.3 Bi-Directional Sync.adoc[]
=== Correlation (Mulesoft)
include::Mulesoft top 5.4 Correlation.adoc[]
=== Aggregation
include::Mulesoft top 5.5 Aggregation.adoc[]




== Top 10 common software Architectural Patterns in a nutshell
=== Layered pattern
include::10 common 1, Layered pattern.adoc[]
=== Client-server pattern
include::10 common 2, Client-server pattern.adoc[]
=== Master-slave pattern
include::10 common 3, Master-slave pattern.adoc[]
=== Pipe-filter pattern
include::10 common 4, Pipe-filter pattern.adoc[]
=== Broker pattern
include::10 common 5, Broker pattern.adoc[]
=== Peer-to-peer pattern
include::10 common 6, Peer-to-peer pattern.adoc[]
=== Event-bus pattern
include::10 common 7, Event-bus pattern.adoc[]
=== Model-view-controller pattern
include::10 common 8, Model-view-controller pattern.adoc[]
=== Blackboard pattern
include::10 common 9, Blackboard pattern.adoc[]
=== Interpreter pattern
include::10 common 10, Interpreter pattern.adoc[]

